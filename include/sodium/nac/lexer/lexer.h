#ifndef SODIUM_NAC_LEXER_LEXER_H
#define SODIUM_NAC_LEXER_LEXER_H

#include <string_view>
#include <unordered_map>

#include "sodium/nac/basic/source_location.h"
#include "sodium/nac/token/token.h"

namespace sodium {

class File;
class TokenBuffer;

const auto RESERVED_WORDS = std::unordered_map<std::string_view, TokenKind>{
    {"func",   TokenKind::KEYWORD_FUNC  },
    {"return", TokenKind::KEYWORD_RETURN},
    {"int",    TokenKind::TYPE          }
};

/// Used to extract any recognised Sodium programing language tokens from a string.
class Lexer {
public:
    /// Constructor for Lexer.
    /// \param file The file of which the contents are to be tokenized.
    Lexer(const File &file);

    /// Constructor for Lexer.
    /// \param src The string to be tokenized.
    Lexer(std::string_view src);

    /// \return A TokenBuffer of all the valid tokens generated by \c this lexer.
    TokenBuffer tokenize();

    /// \returns The next Token generated by \c this lexer. The token could be a TokenKind:ERROR_TOKEN.
    Token next_token();

private:
    std::string_view::const_iterator current_; // the current character
    std::string_view::const_iterator end_;     // the end of the string

    int line_;   // the current line number of the token
    int column_; // te current column number of the token

    int length_; // the length of the current token

    [[nodiscard]] Token make_token(TokenKind kind, SourceLocation start) const;

    void consume_identifier();      // advance the lexer over the identifier
    void consume_integer_literal(); // advance the lexer over the integer literal

    void advance();
    void skip_whitespace();
    void handle_newline();

    // returns true if we are at the end of the string
    [[nodiscard]] bool at_end(std::string_view::const_iterator iterator) const;

    // returns true if the provided identifier is a reserved wor din Sodium
    static bool is_reserved(std::string_view identifier) {
        return RESERVED_WORDS.contains(identifier);
    }

    // returns true if the provided character is a valid character to start an identifier
    static bool is_identifier_start(char c) {
        return is_alpha(c) || c == '_';
    }

    static bool is_alpha(char c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    }

    static bool is_digit(char c) {
        return c >= '0' && c <= '9';
    }

    static bool is_space(char c) {
        return c == '\t' || c == '\v' || c == '\f' || c == '\r' || c == '\n' || c == ' ';
    }
};

} // namespace sodium

#endif // SODIUM_NAC_LEXER_LEXER_H
