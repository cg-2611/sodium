#ifndef SODIUM_NAC_LEXER_LEXER_H
#define SODIUM_NAC_LEXER_LEXER_H

#include <memory>
#include <string_view>
#include <unordered_map>

#include "sodium/nac/basic/source_location.h"
#include "sodium/nac/token/token.h"

namespace sodium {

class DiagnosticEngine;
class LexerError;
class TokenBuffer;

enum class LexerErrorKind;

const auto RESERVED_WORDS = std::unordered_map<std::string_view, TokenKind>{
    {"func",   TokenKind::KEYWORD_FUNC  },
    {"return", TokenKind::KEYWORD_RETURN},
    {"int",    TokenKind::TYPE          }
};

/// Used to extract any recognised Sodium programing language tokens from a string.
class Lexer {
public:
    /// Constructor for Lexer.
    /// \param src The string to be tokenized.
    /// \param diagnostics The DiagnosticEngine to report errors to.
    Lexer(std::string_view src, DiagnosticEngine &diagnostics);

    /// \return A TokenBuffer of all the valid tokens generated by \c this lexer.
    TokenBuffer tokenize();

    /// \returns The next Token generated by \c this lexer. The token could be a TokenKind:ERROR_TOKEN.
    Token next_token();

private:
    DiagnosticEngine &diagnostics_;

    std::string_view::const_iterator token_start_;  // the start of the current token
    std::string_view::const_iterator current_char_; // the current character
    std::string_view::const_iterator string_end_;   // the end of the string

    int line_;   // the current line number of the token
    int column_; // te current column number of the token

    int length_; // the length of the current token

    // returns a token with given kind at given location
    [[nodiscard]] Token make_token(TokenKind kind, SourceLocation start) const;

    // diagnoses a lexer error and returns the error token
    [[nodiscard]] Token make_lexer_error(LexerErrorKind kind, SourceLocation location) const;

    void consume_identifier();      // advance the lexer over the identifier
    void consume_integer_literal(); // advance the lexer over the integer literal

    void advance();
    void skip_whitespace();
    void handle_newline();

    // returns true if we are at the end of the string
    [[nodiscard]] bool at_end() const;

    // returns true if the provided identifier is a reserved wor din Sodium
    static bool is_reserved(std::string_view identifier) {
        return RESERVED_WORDS.contains(identifier);
    }

    // returns true if the provided character is a valid character to start an identifier
    static bool is_identifier_start(char c) {
        return is_alpha(c) || c == '_';
    }

    static bool is_alpha(char c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    }

    static bool is_digit(char c) {
        return c >= '0' && c <= '9';
    }

    static bool is_space(char c) {
        return c == '\t' || c == '\v' || c == '\f' || c == '\r' || c == '\n' || c == ' ';
    }
};

} // namespace sodium

#endif // SODIUM_NAC_LEXER_LEXER_H
